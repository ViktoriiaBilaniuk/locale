"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors = require("./../../errors");
var manipulation_1 = require("./../../manipulation");
var utils_1 = require("./../../utils");
var common_1 = require("./../common");
var ExportDeclaration = /** @class */ (function (_super) {
    __extends(ExportDeclaration, _super);
    function ExportDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Sets the import specifier.
     * @param text - Text to set as the import specifier.
     */
    ExportDeclaration.prototype.setModuleSpecifier = function (text) {
        var stringLiteral = this.getLastChildByKind(ts.SyntaxKind.StringLiteral);
        if (stringLiteral == null) {
            var semiColonToken = this.getLastChildIfKind(ts.SyntaxKind.SemicolonToken);
            var stringChar = this.global.manipulationSettings.getStringChar();
            manipulation_1.insertIntoParent({
                insertPos: semiColonToken != null ? semiColonToken.getPos() : this.getEnd(),
                childIndex: semiColonToken != null ? semiColonToken.getChildIndex() : this.getChildCount(),
                insertItemsCount: 2,
                parent: this,
                newText: " from " + stringChar + text + stringChar
            });
        }
        else {
            manipulation_1.insertIntoParent({
                parent: this,
                newText: text,
                insertPos: stringLiteral.getStart() + 1,
                childIndex: stringLiteral.getChildIndex(),
                insertItemsCount: 1,
                replacing: {
                    textLength: stringLiteral.getWidth() - 2,
                    nodes: [stringLiteral]
                }
            });
        }
        return this;
    };
    /**
     * Gets the module specifier or undefined if it doesn't exist.
     */
    ExportDeclaration.prototype.getModuleSpecifier = function () {
        var stringLiteral = this.getLastChildByKind(ts.SyntaxKind.StringLiteral);
        if (stringLiteral == null)
            return undefined;
        var text = stringLiteral.getText();
        return text.substring(1, text.length - 1);
    };
    /**
     * Gets if the module specifier exists
     */
    ExportDeclaration.prototype.hasModuleSpecifier = function () {
        return this.getLastChildByKind(ts.SyntaxKind.StringLiteral) != null;
    };
    /**
     * Gets if this export declaration is a namespace export.
     */
    ExportDeclaration.prototype.isNamespaceExport = function () {
        return !this.hasNamedExports();
    };
    /**
     * Gets if the export declaration has named exports.
     */
    ExportDeclaration.prototype.hasNamedExports = function () {
        return this.getFirstChildByKind(ts.SyntaxKind.NamedExports) != null;
    };
    /**
     * Add a named export.
     * @param structure - Structure that represents the named export.
     */
    ExportDeclaration.prototype.addNamedExport = function (structure) {
        return this.addNamedExports([structure])[0];
    };
    /**
     * Add named exports.
     * @param structures - Structures that represent the named exports.
     */
    ExportDeclaration.prototype.addNamedExports = function (structures) {
        return this.insertNamedExports(this.getNamedExports().length, structures);
    };
    /**
     * Insert a named export.
     * @param index - Index to insert at.
     * @param structure - Structure that represents the named export.
     */
    ExportDeclaration.prototype.insertNamedExport = function (index, structure) {
        return this.insertNamedExports(index, [structure])[0];
    };
    /**
     * Inserts named exports into the export declaration.
     * @param index - Index to insert at.
     * @param structures - Structures that represent the named exports.
     */
    ExportDeclaration.prototype.insertNamedExports = function (index, structures) {
        if (utils_1.ArrayUtils.isNullOrEmpty(structures))
            return [];
        var namedExports = this.getNamedExports();
        var codes = structures.map(function (s) {
            var text = s.name;
            if (s.alias != null && s.alias.length > 0)
                text += " as " + s.alias;
            return text;
        });
        index = manipulation_1.verifyAndGetIndex(index, namedExports.length);
        if (namedExports.length === 0) {
            var asteriskToken = this.getFirstChildByKindOrThrow(ts.SyntaxKind.AsteriskToken);
            manipulation_1.insertIntoParent({
                insertPos: asteriskToken.getStart(),
                parent: this,
                newText: "{" + codes.join(", ") + "}",
                childIndex: asteriskToken.getChildIndex(),
                insertItemsCount: 1,
                replacing: {
                    nodes: [asteriskToken],
                    textLength: 1
                }
            });
        }
        else {
            manipulation_1.insertIntoCommaSeparatedNodes({ parent: this, currentNodes: namedExports, insertIndex: index, newTexts: codes });
        }
        return this.getNamedExports().slice(index, index + structures.length);
    };
    /**
     * Gets the named exports.
     */
    ExportDeclaration.prototype.getNamedExports = function () {
        var namedExports = this.getFirstChildByKind(ts.SyntaxKind.NamedExports);
        if (namedExports == null)
            return [];
        return namedExports.getChildSyntaxListOrThrow().getChildren().filter(function (c) { return utils_1.TypeGuards.isExportSpecifier(c); });
    };
    /**
     * Changes the export declaration to namespace export. Removes all the named exports.
     */
    ExportDeclaration.prototype.toNamespaceExport = function () {
        if (!this.hasModuleSpecifier())
            throw new errors.InvalidOperationError("Cannot change to a namespace export when no module specifier exists.");
        var namedExportsNode = this.getFirstChildByKind(ts.SyntaxKind.NamedExports);
        if (namedExportsNode == null)
            return this;
        manipulation_1.insertIntoParent({
            parent: this,
            newText: "*",
            insertPos: namedExportsNode.getStart(),
            childIndex: namedExportsNode.getChildIndex(),
            insertItemsCount: 1,
            replacing: {
                textLength: namedExportsNode.getWidth(),
                nodes: [namedExportsNode]
            }
        });
        return this;
    };
    /**
     * Removes this export declaration.
     */
    ExportDeclaration.prototype.remove = function () {
        manipulation_1.removeStatementedNodeChild(this);
    };
    return ExportDeclaration;
}(common_1.Node));
exports.ExportDeclaration = ExportDeclaration;

//# sourceMappingURL=ExportDeclaration.js.map
