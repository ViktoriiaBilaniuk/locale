"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values)/* istanbul ignore next */ || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var manipulation_1 = require("./../../manipulation");
var errors = require("./../../errors");
var utils_1 = require("./../../utils");
var callBaseFill_1 = require("./../callBaseFill");
var common_1 = require("./../common");
var base_1 = require("./../base");
var namespace_1 = require("./../namespace");
exports.InterfaceDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ExtendsClauseableNode(base_1.HeritageClauseableNode(base_1.TypeParameteredNode(base_1.DocumentationableNode(base_1.AmbientableNode(namespace_1.NamespaceChildableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(common_1.Node)))))))))));
var InterfaceDeclaration = /** @class */ (function (_super) {
    __extends(InterfaceDeclaration, _super);
    function InterfaceDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Fills the node from a structure.
     * @param structure - Structure to fill.
     */
    InterfaceDeclaration.prototype.fill = function (structure) {
        callBaseFill_1.callBaseFill(exports.InterfaceDeclarationBase.prototype, this, structure);
        if (structure.constructSignatures != null)
            this.addConstructSignatures(structure.constructSignatures);
        if (structure.properties != null)
            this.addProperties(structure.properties);
        if (structure.methods != null)
            this.addMethods(structure.methods);
        return this;
    };
    /**
     * Add construct signature.
     * @param structure - Structure representing the construct signature.
     */
    InterfaceDeclaration.prototype.addConstructSignature = function (structure) {
        return this.addConstructSignatures([structure])[0];
    };
    /**
     * Add construct signatures.
     * @param structures - Structures representing the construct signatures.
     */
    InterfaceDeclaration.prototype.addConstructSignatures = function (structures) {
        return this.insertConstructSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert construct signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the construct signature.
     */
    InterfaceDeclaration.prototype.insertConstructSignature = function (index, structure) {
        return this.insertConstructSignatures(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the construct signatures.
     */
    InterfaceDeclaration.prototype.insertConstructSignatures = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = [];
        try {
            for (var structures_1 = __values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {
                var structure = structures_1_1.value;
                var code = indentationText + "new()";
                if (structure.returnType != null && structure.returnType.length > 0)
                    code += ": " + structure.returnType;
                code += ";";
                codes.push(code);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.ConstructSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
        var e_1, _a;
    };
    /**
     * Gets the first construct signature by a find function.
     * @param findFunction - Function to find the construct signature by.
     */
    InterfaceDeclaration.prototype.getConstructSignature = function (findFunction) {
        return utils_1.ArrayUtils.find(this.getConstructSignatures(), findFunction);
    };
    /**
     * Gets the first construct signature by a find function or throws if not found.
     * @param findFunction - Function to find the construct signature by.
     */
    InterfaceDeclaration.prototype.getConstructSignatureOrThrow = function (findFunction) {
        return errors.throwIfNullOrUndefined(this.getConstructSignature(findFunction), "Expected to find a construct signature with the provided condition.");
    };
    /**
     * Gets the interface method signatures.
     */
    InterfaceDeclaration.prototype.getConstructSignatures = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.ConstructSignature; })
            .map(function (m) { return _this.global.compilerFactory.getNodeFromCompilerNode(m, _this.sourceFile); });
    };
    /**
     * Add method.
     * @param structure - Structure representing the method.
     */
    InterfaceDeclaration.prototype.addMethod = function (structure) {
        return this.addMethods([structure])[0];
    };
    /**
     * Add methods.
     * @param structures - Structures representing the methods.
     */
    InterfaceDeclaration.prototype.addMethods = function (structures) {
        return this.insertMethods(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert method.
     * @param index - Index to insert at.
     * @param structure - Structure representing the method.
     */
    InterfaceDeclaration.prototype.insertMethod = function (index, structure) {
        return this.insertMethods(index, [structure])[0];
    };
    /**
     * Insert methods.
     * @param index - Index to insert at.
     * @param structures - Structures representing the methods.
     */
    InterfaceDeclaration.prototype.insertMethods = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = [];
        try {
            for (var structures_2 = __values(structures), structures_2_1 = structures_2.next(); !structures_2_1.done; structures_2_1 = structures_2.next()) {
                var structure = structures_2_1.value;
                var code = indentationText;
                code += structure.name;
                if (structure.hasQuestionToken)
                    code += "?";
                code += "()";
                if (structure.returnType != null && structure.returnType.length > 0)
                    code += ": " + structure.returnType;
                code += ";";
                codes.push(code);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (structures_2_1 && !structures_2_1.done && (_a = structures_2.return)) _a.call(structures_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // insert, fill, and get created nodes
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.MethodSignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
        var e_2, _a;
    };
    InterfaceDeclaration.prototype.getMethod = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
    };
    InterfaceDeclaration.prototype.getMethodOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface method signature", nameOrFindFunction); });
    };
    /**
     * Gets the interface method signatures.
     */
    InterfaceDeclaration.prototype.getMethods = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.MethodSignature; })
            .map(function (m) { return _this.global.compilerFactory.getNodeFromCompilerNode(m, _this.sourceFile); });
    };
    /**
     * Add property.
     * @param structure - Structure representing the property.
     */
    InterfaceDeclaration.prototype.addProperty = function (structure) {
        return this.addProperties([structure])[0];
    };
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    InterfaceDeclaration.prototype.addProperties = function (structures) {
        return this.insertProperties(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);
    };
    /**
     * Insert property.
     * @param index - Index to insert at.
     * @param structure - Structure representing the property.
     */
    InterfaceDeclaration.prototype.insertProperty = function (index, structure) {
        return this.insertProperties(index, [structure])[0];
    };
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    InterfaceDeclaration.prototype.insertProperties = function (index, structures) {
        var _this = this;
        var indentationText = this.getChildIndentationText();
        // create code
        var codes = [];
        try {
            for (var structures_3 = __values(structures), structures_3_1 = structures_3.next(); !structures_3_1.done; structures_3_1 = structures_3.next()) {
                var structure = structures_3_1.value;
                var code = "" + indentationText;
                code += structure.name;
                if (structure.hasQuestionToken)
                    code += "?";
                if (structure.type != null && structure.type.length > 0)
                    code += ": " + structure.type;
                code += ";";
                codes.push(code);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (structures_3_1 && !structures_3_1.done && (_a = structures_3.return)) _a.call(structures_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return manipulation_1.insertIntoBracesOrSourceFileWithFillAndGetChildren({
            getIndexedChildren: function () { return _this.getAllMembers(); },
            sourceFile: this.getSourceFile(),
            parent: this,
            index: index,
            childCodes: codes,
            structures: structures,
            expectedKind: ts.SyntaxKind.PropertySignature,
            fillFunction: function (node, structure) { return node.fill(structure); }
        });
        var e_3, _a;
    };
    InterfaceDeclaration.prototype.getProperty = function (nameOrFindFunction) {
        return utils_1.getNamedNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
    };
    InterfaceDeclaration.prototype.getPropertyOrThrow = function (nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction("interface property signature", nameOrFindFunction); });
    };
    /**
     * Gets the interface property signatures.
     */
    InterfaceDeclaration.prototype.getProperties = function () {
        var _this = this;
        return this.compilerNode.members.filter(function (m) { return m.kind === ts.SyntaxKind.PropertySignature; })
            .map(function (m) { return _this.global.compilerFactory.getNodeFromCompilerNode(m, _this.sourceFile); });
    };
    /**
     * Gets all members.
     */
    InterfaceDeclaration.prototype.getAllMembers = function () {
        var _this = this;
        return this.compilerNode.members.map(function (m) { return _this.global.compilerFactory.getNodeFromCompilerNode(m, _this.sourceFile); });
    };
    /**
     * Gets all the implementations of the interface.
     *
     * This is similar to "go to implementation."
     */
    InterfaceDeclaration.prototype.getImplementations = function () {
        return this.getNameNode().getImplementations();
    };
    /**
     * Removes this interface declaration.
     */
    InterfaceDeclaration.prototype.remove = function () {
        manipulation_1.removeStatementedNodeChild(this);
    };
    return InterfaceDeclaration;
}(exports.InterfaceDeclarationBase));
exports.InterfaceDeclaration = InterfaceDeclaration;

//# sourceMappingURL=InterfaceDeclaration.js.map
