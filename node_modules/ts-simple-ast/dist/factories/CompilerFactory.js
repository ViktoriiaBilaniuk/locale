"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var compiler = require("./../compiler");
var errors = require("./../errors");
var utils_1 = require("./../utils");
var GlobalContainer_1 = require("./../GlobalContainer");
var fileSystem_1 = require("./../fileSystem");
var nodeToWrapperMappings_1 = require("./nodeToWrapperMappings");
/**
 * Factory for creating compiler wrappers.
 * @internal
 */
var CompilerFactory = /** @class */ (function () {
    /**
     * Initializes a new instance of CompilerFactory.
     * @param global - Global container.
     */
    function CompilerFactory(global) {
        this.global = global;
        this.sourceFileCacheByFilePath = new utils_1.KeyValueCache();
        this.normalizedDirectories = utils_1.createHashSet();
        this.nodeCache = new utils_1.KeyValueCache();
        this.sourceFileAddedEventContainer = new utils_1.EventContainer();
    }
    /**
     * Occurs when a source file is added to the cache.
     * @param subscription - Subscripton.
     */
    CompilerFactory.prototype.onSourceFileAdded = function (subscription) {
        this.sourceFileAddedEventContainer.subscribe(subscription);
    };
    /**
     * Creates a source file from a file path and text.
     * Adds it to the cache.
     * @param filePath - File path for the source file.
     * @param sourceText - Text to create the source file with.
     */
    CompilerFactory.prototype.addSourceFileFromText = function (filePath, sourceText) {
        var absoluteFilePath = utils_1.FileUtils.getStandardizedAbsolutePath(filePath);
        if (this.containsSourceFileAtPath(absoluteFilePath))
            throw new errors.InvalidOperationError("A source file already exists at the provided file path: " + absoluteFilePath);
        var compilerSourceFile = ts.createSourceFile(absoluteFilePath, sourceText, this.global.manipulationSettings.getScriptTarget(), true);
        return this.getSourceFile(compilerSourceFile);
    };
    /**
     * Creates a temporary source file that won't be added to the language service.
     * @param sourceText - Text to create the source file with.
     * @param filePath - File path to use.
     * @returns Wrapped source file.
     */
    CompilerFactory.prototype.createTempSourceFileFromText = function (sourceText, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = opts.filePath, filePath = _a === void 0 ? "tsSimpleAstTempFile.ts" : _a, _b = opts.createLanguageService, createLanguageService = _b === void 0 ? false : _b;
        var globalContainer = new GlobalContainer_1.GlobalContainer(new fileSystem_1.VirtualFileSystemHost(), this.global.compilerOptions, createLanguageService);
        return globalContainer.compilerFactory.addSourceFileFromText(filePath, sourceText);
    };
    /**
     * Gets a source file from a file path. Will use the file path cache if the file exists.
     * @param filePath - File path to get the file from.
     */
    CompilerFactory.prototype.getSourceFileFromFilePath = function (filePath) {
        var absoluteFilePath = utils_1.FileUtils.getStandardizedAbsolutePath(filePath);
        var sourceFile = this.sourceFileCacheByFilePath.get(absoluteFilePath);
        if (sourceFile == null) {
            if (this.global.fileSystem.fileExistsSync(absoluteFilePath)) {
                utils_1.Logger.log("Loading file: " + absoluteFilePath);
                sourceFile = this.addSourceFileFromText(absoluteFilePath, this.global.fileSystem.readFile(absoluteFilePath));
                sourceFile.setIsSaved(true); // source files loaded from the disk are saved to start with
            }
            if (sourceFile != null) {
                // ensure these are added to the ast
                sourceFile.getReferencedFiles();
                sourceFile.getTypeReferenceDirectives();
            }
        }
        return sourceFile;
    };
    /**
     * Gets if the internal cache contains a source file at a specific file path.
     * @param filePath - File path to check.
     */
    CompilerFactory.prototype.containsSourceFileAtPath = function (filePath) {
        var absoluteFilePath = utils_1.FileUtils.getStandardizedAbsolutePath(filePath);
        return this.sourceFileCacheByFilePath.get(absoluteFilePath) != null;
    };
    /**
     * Gets if the internal cache contains a source file with the specified directory path.
     * @param dirPath - Directory path to check.
     */
    CompilerFactory.prototype.containsFileInDirectory = function (dirPath) {
        var normalizedDirPath = utils_1.FileUtils.getStandardizedAbsolutePath(dirPath);
        return this.normalizedDirectories.has(normalizedDirPath);
    };
    /**
     * Gets the source file for a node.
     * @param compilerNode - Compiler node to get the source file of.
     */
    CompilerFactory.prototype.getSourceFileForNode = function (compilerNode) {
        var currentNode = compilerNode;
        while (currentNode.kind !== ts.SyntaxKind.SourceFile) {
            if (currentNode.parent == null)
                throw new errors.NotImplementedError("Could not find node source file.");
            currentNode = currentNode.parent;
        }
        return this.getSourceFile(currentNode);
    };
    /**
     * Gets if the factory contains the compiler node in its internal cache.
     * @param compilerNode - Compiler node.
     */
    CompilerFactory.prototype.hasCompilerNode = function (compilerNode) {
        return this.nodeCache.has(compilerNode);
    };
    /**
     * Gets an existing node from the cache.
     * @param compilerNode - Compiler node.
     */
    CompilerFactory.prototype.getExistingCompilerNode = function (compilerNode) {
        return this.nodeCache.get(compilerNode);
    };
    /**
     * Gets a wrapped compiler type based on the node's kind.
     * @param node - Node to get the wrapped object from.
     */
    CompilerFactory.prototype.getNodeFromCompilerNode = function (compilerNode, sourceFile) {
        var _this = this;
        if (compilerNode.kind === ts.SyntaxKind.SourceFile)
            return this.getSourceFile(compilerNode);
        var createNode = function (ctor) {
            // ensure the parent is created
            if (compilerNode.parent != null && !_this.nodeCache.has(compilerNode.parent))
                _this.getNodeFromCompilerNode(compilerNode.parent, sourceFile);
            return new ctor(_this.global, compilerNode, sourceFile);
        };
        if (nodeToWrapperMappings_1.nodeToWrapperMappings[compilerNode.kind] != null)
            return this.nodeCache.getOrCreate(compilerNode, function () { return createNode(nodeToWrapperMappings_1.nodeToWrapperMappings[compilerNode.kind]); });
        else
            return this.nodeCache.getOrCreate(compilerNode, function () { return createNode(compiler.Node); });
    };
    /**
     * Gets a wrapped source file from a compiler source file.
     * @param sourceFile - Compiler source file.
     */
    CompilerFactory.prototype.getSourceFile = function (compilerSourceFile) {
        var _this = this;
        return this.nodeCache.getOrCreate(compilerSourceFile, function () {
            var sourceFile = new compiler.SourceFile(_this.global, compilerSourceFile);
            _this.sourceFileCacheByFilePath.set(sourceFile.getFilePath(), sourceFile);
            // add to list of directories
            var normalizedDir = utils_1.FileUtils.getStandardizedAbsolutePath(utils_1.FileUtils.getDirPath(sourceFile.getFilePath()));
            if (!_this.normalizedDirectories.has(normalizedDir))
                _this.normalizedDirectories.add(normalizedDir);
            // fire the event
            _this.sourceFileAddedEventContainer.fire({
                addedSourceFile: sourceFile
            });
            return sourceFile;
        });
    };
    /**
     * Gets a warpped symbol display part form a compiler symbol display part.
     * @param compilerObject - Compiler symbol display part.
     */
    CompilerFactory.prototype.getSymbolDisplayPart = function (compilerObject) {
        return new compiler.SymbolDisplayPart(compilerObject);
    };
    /**
     * Gets a wrapped type from a compiler type.
     * @param type - Compiler type.
     */
    CompilerFactory.prototype.getType = function (type) {
        return new compiler.Type(this.global, type);
    };
    /**
     * Gets a warpped type parameter from a compiler type parameter.
     * @param typeParameter - Compiler type parameter
     */
    CompilerFactory.prototype.getTypeParameter = function (typeParameter) {
        return new compiler.TypeParameter(this.global, typeParameter);
    };
    /**
     * Gets a wrapped signature from a compiler signature.
     * @param signature - Compiler signature.
     */
    CompilerFactory.prototype.getSignature = function (signature) {
        return new compiler.Signature(this.global, signature);
    };
    /**
     * Gets a wrapped symbol from a compiler symbol.
     * @param symbol - Compiler symbol.
     */
    CompilerFactory.prototype.getSymbol = function (symbol) {
        return new compiler.Symbol(this.global, symbol);
    };
    /**
     * Gets a wrapped diagnostic from a compiler diagnostic.
     * @param diagnostic - Compiler diagnostic.
     */
    CompilerFactory.prototype.getDiagnostic = function (diagnostic) {
        return new compiler.Diagnostic(this.global, diagnostic);
    };
    /**
     * Gets a wrapped diagnostic message chain from a compiler diagnostic message chain.
     * @param diagnostic - Compiler diagnostic message chain.
     */
    CompilerFactory.prototype.getDiagnosticMessageChain = function (diagnosticMessageChain) {
        return new compiler.DiagnosticMessageChain(this.global, diagnosticMessageChain);
    };
    /**
     * Gets a warpped JS doc tag info from a compiler object.
     * @param jsDocTagInfo - Compiler object.
     */
    CompilerFactory.prototype.getJSDocTagInfo = function (jsDocTagInfo) {
        return new compiler.JSDocTagInfo(jsDocTagInfo);
    };
    /**
     * Replaces a compiler node in the cache.
     * @param oldNode - Old node to remove.
     * @param newNode - New node to use.
     */
    CompilerFactory.prototype.replaceCompilerNode = function (oldNode, newNode) {
        var nodeToReplace = oldNode instanceof compiler.Node ? oldNode.compilerNode : oldNode;
        var node = oldNode instanceof compiler.Node ? oldNode : this.nodeCache.get(oldNode);
        this.nodeCache.replaceKey(nodeToReplace, newNode);
        if (node != null)
            node.replaceCompilerNode(newNode);
    };
    /**
     * Removes a node from the cache.
     * @param node - Node to remove.
     */
    CompilerFactory.prototype.removeNodeFromCache = function (node) {
        var compilerNode = node.compilerNode;
        this.nodeCache.removeByKey(compilerNode);
        if (compilerNode.kind === ts.SyntaxKind.SourceFile) {
            var sourceFile = compilerNode;
            this.sourceFileCacheByFilePath.removeByKey(sourceFile.fileName);
        }
    };
    return CompilerFactory;
}());
exports.CompilerFactory = CompilerFactory;

//# sourceMappingURL=CompilerFactory.js.map
