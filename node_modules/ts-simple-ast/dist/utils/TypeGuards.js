"use strict";
// -----------------------
// WARNING - DO NOT modify the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts
//
// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).
// -----------------------
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var ts = require("typescript");
/**
 * Type guards for checking the type of a node.
 */
var TypeGuards = /** @class */ (function () {
    /* istanbul ignore next */ function TypeGuards() {
    }
    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    TypeGuards.isAbstractableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    TypeGuards.isAmbientableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    TypeGuards.isArgumentedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.CallExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is an ArrayLiteralExpression.
     * @param node - Node to check.
     */
    TypeGuards.isArrayLiteralExpression = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ArrayLiteralExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    TypeGuards.isAsyncableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    TypeGuards.isBindingNamedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    TypeGuards.isBodiedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    TypeGuards.isBodyableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a CallExpression.
     * @param node - Node to check.
     */
    TypeGuards.isCallExpression = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.CallExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    TypeGuards.isChildOrderableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ClassDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isClassDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ComputedPropertyName.
     * @param node - Node to check.
     */
    TypeGuards.isComputedPropertyName = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ComputedPropertyName:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isConstructSignatureDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ConstructSignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isConstructorDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a DeclarationNamedNode.
     * @param node - Node to check.
     */
    TypeGuards.isDeclarationNamedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    TypeGuards.isDecoratableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a Decorator.
     * @param node - Node to check.
     */
    TypeGuards.isDecorator = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Decorator:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a DocumentationableNode.
     * @param node - Node to check.
     */
    TypeGuards.isDocumentationableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.EnumMember:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a EnumDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isEnumDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.EnumDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a EnumMember.
     * @param node - Node to check.
     */
    TypeGuards.isEnumMember = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.EnumMember:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ExportDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isExportDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ExportDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ExportSpecifier.
     * @param node - Node to check.
     */
    TypeGuards.isExportSpecifier = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ExportSpecifier:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ExportableNode.
     * @param node - Node to check.
     */
    TypeGuards.isExportableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ExpressionWithTypeArguments.
     * @param node - Node to check.
     */
    TypeGuards.isExpressionWithTypeArguments = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ExtendsClauseableNode.
     * @param node - Node to check.
     */
    TypeGuards.isExtendsClauseableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a FunctionDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isFunctionDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a FunctionExpression.
     * @param node - Node to check.
     */
    TypeGuards.isFunctionExpression = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isFunctionLikeDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    TypeGuards.isGeneratorableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isGetAccessorDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.GetAccessor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a HeritageClause.
     * @param node - Node to check.
     */
    TypeGuards.isHeritageClause = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.HeritageClause:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    TypeGuards.isHeritageClauseableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a Identifier.
     * @param node - Node to check.
     */
    TypeGuards.isIdentifier = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Identifier:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    TypeGuards.isImplementsClauseableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ImportDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isImportDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ImportDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ImportSpecifier.
     * @param node - Node to check.
     */
    TypeGuards.isImportSpecifier = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ImportSpecifier:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    TypeGuards.isInitializerExpressionableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.EnumMember:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a InitializerGetExpressionableNode.
     * @param node - Node to check.
     */
    TypeGuards.isInitializerGetExpressionableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.PropertyAssignment:
            case ts.SyntaxKind.ShorthandPropertyAssignment:
            case ts.SyntaxKind.EnumMember:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a InitializerSetExpressionableNode.
     * @param node - Node to check.
     */
    TypeGuards.isInitializerSetExpressionableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.EnumMember:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a InterfaceDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isInterfaceDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    TypeGuards.isJSDoc = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocComment:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocAugmentsTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocAugmentsTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocAugmentsTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocClassTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocClassTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocClassTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocPropertyLikeTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocPropertyTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocPropertyTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocReturnTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocReturnTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocReturnTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocTypeTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocTypeTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocTypeTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocTypedefTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocTypedefTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocTypedefTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    TypeGuards.isJSDocUnknownTag = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    TypeGuards.isLiteralLikeNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.FirstLiteralToken:
            case ts.SyntaxKind.RegularExpressionLiteral:
            case ts.SyntaxKind.StringLiteral:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a MethodDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isMethodDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.MethodDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a MethodSignature.
     * @param node - Node to check.
     */
    TypeGuards.isMethodSignature = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.MethodSignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    TypeGuards.isModifierableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    TypeGuards.isNameableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    TypeGuards.isNamedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.ShorthandPropertyAssignment:
            case ts.SyntaxKind.PropertyAccessExpression:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.TypeAliasDeclaration:
            case ts.SyntaxKind.TypeParameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    TypeGuards.isNamespaceChildableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
            case ts.SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isNamespaceDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a NumericLiteral.
     * @param node - Node to check.
     */
    TypeGuards.isNumericLiteral = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.FirstLiteralToken:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ObjectLiteralExpression.
     * @param node - Node to check.
     */
    TypeGuards.isObjectLiteralExpression = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ObjectLiteralExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    TypeGuards.isOverloadableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isParameterDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    TypeGuards.isParameteredNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.MethodSignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a PropertyAccessExpression.
     * @param node - Node to check.
     */
    TypeGuards.isPropertyAccessExpression = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyAccessExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a PropertyAssignment.
     * @param node - Node to check.
     */
    TypeGuards.isPropertyAssignment = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a PropertyDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isPropertyDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    TypeGuards.isPropertyNamedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.PropertyAssignment:
            case ts.SyntaxKind.EnumMember:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a PropertySignature.
     * @param node - Node to check.
     */
    TypeGuards.isPropertySignature = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a QualifiedName.
     * @param node - Node to check.
     */
    TypeGuards.isQualifiedName = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.QualifiedName:
            case ts.SyntaxKind.FirstNode:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    TypeGuards.isQuestionTokenableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.PropertyAssignment:
            case ts.SyntaxKind.ShorthandPropertyAssignment:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    TypeGuards.isReadonlyableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a RegularExpressionLiteral.
     * @param node - Node to check.
     */
    TypeGuards.isRegularExpressionLiteral = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.RegularExpressionLiteral:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    TypeGuards.isReturnTypedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.MethodSignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    TypeGuards.isScopeableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    TypeGuards.isScopedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isSetAccessorDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     * @param node - Node to check.
     */
    TypeGuards.isShorthandPropertyAssignment = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isSignaturedDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.MethodSignature:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a SourceFile.
     * @param node - Node to check.
     */
    TypeGuards.isSourceFile = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a SpreadAssignment.
     * @param node - Node to check.
     */
    TypeGuards.isSpreadAssignment = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    TypeGuards.isStatementedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.SourceFile:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    TypeGuards.isStaticableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a StringLiteral.
     * @param node - Node to check.
     */
    TypeGuards.isStringLiteral = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.StringLiteral:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a SyntaxList.
     * @param node - Node to check.
     */
    TypeGuards.isSyntaxList = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.SyntaxList:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    TypeGuards.isTextInsertableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.SourceFile:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeAliasDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isTypeAliasDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    TypeGuards.isTypeArgumentedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.CallExpression:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    TypeGuards.isTypeNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.FirstTypeNode:
            case ts.SyntaxKind.LastTypeNode:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isTypeParameterDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.TypeParameter:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    TypeGuards.isTypeParameteredNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.Constructor:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ConstructSignature:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    TypeGuards.isTypeReferenceNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.TypeReference:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    TypeGuards.isTypedNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.PropertyDeclaration:
            case ts.SyntaxKind.Parameter:
            case ts.SyntaxKind.PropertySignature:
            case ts.SyntaxKind.VariableDeclaration:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    TypeGuards.isUnwrappableNode = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a VariableDeclaration.
     * @param node - Node to check.
     */
    TypeGuards.isVariableDeclaration = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    };
    /**
     * Gets if the node is a VariableStatement.
     * @param node - Node to check.
     */
    TypeGuards.isVariableStatement = function (node) {
        switch (node.getKind()) {
            case ts.SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    };
    return TypeGuards;
}());
exports.TypeGuards = TypeGuards;

//# sourceMappingURL=TypeGuards.js.map
